import { Notes } from 'spectacle'
import { CodeSlide } from './slides'
import CodePane from './components/CodePane'
import ReduxLogo from './components/ReduxLogo'
import CodeRunner from './components/CodeRunner'

<ReduxLogo />

# Redux Recommendations

---
export const transition = ['zoom']

# Overview

- Reduce Boilerplate with Utilities
- Simplify API Calls with Middleware
- Improve Code Structure with Ducks

---

##### Reduce Boilerplate with Utilities
### Action Creators

- Writing simple action creators by hand is tedious
- Defining separate action type constants and action creator functions is a lot
- With a utility, can be one line for many action creators

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/withoutCreateAction.js')}
/>

<Notes>

- Vanilla Redux
- Separate action type constant and creator function
- Grows big when you have a lot of actions

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/createAction.js')}
/>
<CodeRunner name="createAction" importer={() => import('./examples/createAction')} />

<Notes>

- Example from redux-starter-kit library
- From the Redux core team
- Provides `createAction` utility
- Check out the output

</Notes>

---

##### Reduce Boilerplate with Utilities
### Reducers

- Prefer utilities to `switch`
- Code in `case` sections isn't really isolated
- You have to watch for the dreaded forgotten `break`

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/switchReducer.js')}
/>

<Notes>

- Basic `switch` reducer example
- Each action type gets a `case`
- Don't forget to `break`, or next `case` will start
- Cases may share variables and so aren't isolated

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/utilReducer.js')}
/>

<Notes>

- Example of creating reducer w/ utility
- Provide map of action type to function for just that action type
- Returns a reducer function
- When run, forwards action to correct function based on its type
- Code for handling each type of action is isolated

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/createReducer.js')}
/>

<Notes>

- Implementing is straightforward
- Function that takes reducer map
- Returns reducer function
- Reducer function looks up appropriate function in map and executes
- If no matching function, just return state as-is

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/rskReducer.js')}
/>
<CodeRunner name="rskReducer" importer={() => import('./examples/rskReducer')} />

<Notes>

- redux-starter-kit provides its own `createReducer`
- Similarly to last example, takes a map
- Action creators can be used in map, as their `type` property will automatically become the key
- Uses Immer.js to create a draft copy of your state that you can mutate
- But resulting returned state is updated immutably

</Notes>

---

##### Simplify API Calls with Middleware

- Manual API calls lead to boilerplate
- Loading and error states handled inconsistently or not at all
- Manual code requires more work to test

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/manualApiCall.js')}
/>

<Notes>

- Have to dispatch all three action types every time
- Can't use `catch` or you'll get errors from reducer and React code
- Have to write about the same tests every time
  - Including mocking with dummy promises

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/declarativeApiCall.js')}
/>
<CodeRunner name="declarativeApiCall" importer={() => import('./examples/declarativeApiCall')} />

<Notes>

- Have something else send api request and dispatch actions for you
- Run example: You get request start and success actions automatically
- Can unit test by just asserting on contents of action object

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/apiCallMiddleware.js')}
/>

<Notes>

- Redux middleware are great for this
- Is a function that intercepts dispatched actions
- Here:
  - Intercepts API call actions
  - Makes API call
  - Dispatches start and success or failure actions

</Notes>

---

##### Simplify API Calls with Middleware
### Libraries

- [redux-api-middleware](https://github.com/agraboso/redux-api-middleware)
- [redux-api](https://github.com/lexich/redux-api)

<Notes>

- If you don't want to roll your own, there are libraries
- redux-api-middleware seems pretty solid

</Notes>