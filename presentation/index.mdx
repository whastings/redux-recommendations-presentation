import { Notes } from 'spectacle'
import { CodeSlide } from './slides'
import CodePane from './components/CodePane'
import ReduxLogo from './components/ReduxLogo'
import CodeRunner from './components/CodeRunner'
import ApiMiddlewareWalkthrough from './walkthroughs/ApiMiddlewareWalkthrough'

<ReduxLogo />

# Redux Recommendations

---

# Overview

- Reduce Boilerplate with Utilities
- Simplify API Calls with Middleware
- Improve Code Structure with Ducks

---

# Reduce Boilerplate with Utilities

---

##### Reduce Boilerplate with Utilities
### Action Creators

- Writing simple action creators by hand is tedious
- Defining separate action type constants and action creator functions is a lot
- With a utility, can be one line for many action creators

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/withoutCreateAction.js')}
/>

<Notes>

- Vanilla Redux
- Separate action type constant and creator function
- Grows big when you have a lot of actions

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/createAction.js')}
/>
<CodeRunner name="createAction" importer={() => import('./examples/createAction')} />

<Notes>

- Example from redux-starter-kit library
- From the Redux core team
- Provides `createAction` utility
- Check out the output

</Notes>

---

##### Reduce Boilerplate with Utilities
### Reducers

- Prefer utilities to `switch`
- Code in `case` sections isn't really isolated
- You have to watch for the dreaded forgotten `break`

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/switchReducer.js')}
/>

<Notes>

- Basic `switch` reducer example
- Each action type gets a `case`
- Don't forget to `break`, or next `case` will start
- Cases may share variables and so aren't isolated

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/utilReducer.js')}
/>

<Notes>

- Example of creating reducer w/ utility
- Provide map of action type to function for just that action type
- Returns a reducer function
- When run, forwards action to correct function based on its type
- Code for handling each type of action is isolated

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/createReducer.js')}
/>

<Notes>

- Implementing is straightforward
- Function that takes reducer map
- Returns reducer function
- Reducer function looks up appropriate function in map and executes
- If no matching function, just return state as-is

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/rskReducer.js')}
/>
<CodeRunner name="rskReducer" importer={() => import('./examples/rskReducer')} />

<Notes>

- redux-starter-kit provides its own `createReducer`
- Similarly to last example, takes a map
- Action creators can be used in map, as their `type` property will automatically become the key
- Uses Immer.js to create a draft copy of your state that you can mutate
- But resulting returned state is updated immutably

</Notes>

---

# Simplify API Calls with Middleware

---

##### Simplify API Calls with Middleware

- Manual API calls lead to boilerplate
- Loading and error states handled inconsistently or not at all
- Manual code requires more work to test

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/manualApiCall.js')}
/>

<Notes>

- Have to dispatch all three action types every time
- Can't use `catch` or you'll get errors from reducer and React code
- Have to write about the same tests every time
  - Including mocking with dummy promises

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/declarativeApiCall.js')}
/>
<CodeRunner name="declarativeApiCall" importer={() => import('./examples/declarativeApiCall')} />

<Notes>

- Have something else send api request and dispatch actions for you
- Run example: You get request start and success actions automatically
- Can unit test by just asserting on contents of action object

</Notes>

---
export default ApiMiddlewareWalkthrough

- Redux middleware are great for this
- Is a function that intercepts dispatched actions

---

##### Simplify API Calls with Middleware
### Libraries

- [redux-api-middleware](https://github.com/agraboso/redux-api-middleware)
- [redux-api](https://github.com/lexich/redux-api)

<Notes>

- If you don't want to roll your own, there are libraries
- redux-api-middleware seems pretty solid

</Notes>

---

# Improve Code Structure with Ducks

---

##### Improve Code Structure with Ducks

- [ducks-modular-redux](https://github.com/erikras/ducks-modular-redux) describes the "Ducks" pattern
- You put action types, actions creators, and reducer in same file (a "Duck")
- Keeps you from jumping around so much
- Follows "code that changes together should live together" principle

<Notes>

- Traditionally, actions and reducers defined in different files
- "Duck" is a pattern proposed by Erik Rasmussen
- It's a file containing action types, action creators, and the reducer for some functionality
- Let's you edit related code in the same file
- So less jumping between files

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/duck.js')}
/>

<Notes>

- Define types, creators, and reducer
- Personally, I'd use `createAction` from redux-starter-kit
- Export action creators as named exports
- Export reducer as the default export
- Can also export action type if you need to use them elsewhere

</Notes>

---
export default CodeSlide

<CodePane
  source={require('!raw-loader!./examples/rskDuck.js')}
/>
<CodeRunner name="rskDuck" importer={() => import('./examples/rskDuck')} />

<Notes>

- redux-starter-kit provides `createSlice` utility
- Let's you put everyone in one file, but with even less boilerplate
- `reducers` hash produces both reducer you'd get with `createReducer` and supporting action creators + types
- Gives you object with `reducer` and `actions` props
- Run code:
  - Note action type prefixed with slice name

</Notes>

---

# Conclusion

---

##### Conclusion
### Summary

- Use utilities to reduce boilerplate
- Build abstractions like middleware to simplify common patterns
- Keep related code close together

---

##### Conclusion
### Learn More

- [redux-starter-kit](https://redux-starter-kit.js.org)
- [rsk-github-issues-example](https://github.com/markerikson/rsk-github-issues-example)
- [redux-api-middleware](https://github.com/agraboso/redux-api-middleware)
- [ducks-modular-redux](https://github.com/erikras/ducks-modular-redux)

<Notes>

- Here are some resources for learning more
- QUESTIONS?

</Notes>
